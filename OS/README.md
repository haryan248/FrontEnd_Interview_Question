## 1. 프로세스와 스레드의 차이

프로세스는 실행중인 프로그램, 메모리에 적재되어 CPU의 할당을 받을 수 있다.

스레드는 프로세스의 실행 단위이며 프로세스 내의 주소공간, 자원을 공유한다.

## 2. 멀티 프로세스와 멀티 스레드의 차이

### 멀티 프로세스

두개 이상 다수의 프로세서(`CPU`)가 협력적으로 하나 이상의 작업(`Task`)을 동시에 처리하는 것

-   하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재

### 멀티 스레드

하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것

-   멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점
    → 자원을 효율적으로 관리가 가능
-   오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제(병목 현상, 데드락)
    -   임계영역에 한번에 한 스레드만 실행되도록 lock, monitor, synchronized를 통해 동기화 문제 해결

멀티 프로세스 예시

-   크롬 탭, 카카오톡 채팅방

## 3. CPU 스케쥴러

비선점형 스케쥴링

-   FCFS, SJF, SRTF

선점형 스케쥴링

-   Priority Scheduling(우선순위 스케쥴링), Round Robin

각각의 스케쥴링 방식을 설명할줄 알아야 한다.

## CPU 스케줄러

_스케줄링 대상은 Ready Queue 에 있는 프로세스들이다._

### FCFS(First Come First Served)

#### 특징

-   먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리.
-   비선점형(Non-Preemptive) 스케줄링  
    일단 CPU 를 잡으면 CPU burst 가 완료될 때까지 CPU 를 반환하지 않는다. 할당되었던 CPU 가 반환될 때만 스케줄링이 이루어진다.

#### 문제점

-   convoy effect  
    소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.

</br>

### SJF(Shortest - Job - First)

#### 특징

-   다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
-   비선점형(Non-Preemptive) 스케줄링

#### 문제점

-   starvation  
    효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job 을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없다.

</br>

### SRTF(Shortest Remaining Time First)

#### 특징

-   새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
-   선점형 (Preemptive) 스케줄링  
    현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.

#### 문제점

-   starvation
-   새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.

</br>

### Priority Scheduling

#### 특징

-   우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링이다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
-   선점형 스케줄링(Preemptive) 방식  
    더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
-   비선점형 스케줄링(Non-Preemptive) 방식  
    더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.

#### 문제점

-   starvation
-   무기한 봉쇄(Indefinite blocking)  
    실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태

#### 해결책

-   aging  
    아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주자.

</br>

### Round Robin

#### 특징

-   현대적인 CPU 스케줄링
-   각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
-   할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
-   `RR`은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
-   `RR`이 가능한 이유는 프로세스의 context 를 save 할 수 있기 때문이다.

#### 장점

-   `Response time`이 빨라진다.  
    n 개의 프로세스가 ready queue 에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n 을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
-   프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가한다.  
    공정한 스케줄링이라고 할 수 있다.

#### 주의할 점

설정한 `time quantum`이 너무 커지면 `FCFS`와 같아진다.
또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다.
그렇기 때문에 적당한 `time quantum`을 설정하는 것이 중요하다.

## 4. 임계영역(Critical Section)

동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역

### 임계영역 해결

**기본 조건**

-   Mutual Exclusion(상호 배제)
    -   한 프로세스가 임계영역에서 실행중이라면 다른 프로세스는 실행될 수 없다
-   Progress(진행)
    -   임계영역에 실행되는 프로세스가 없고, 다른 프로세스만 진입이 가능하다.
-   Bounded Waiting(한정된 대기)
    -   임계영역에 프로세스가 들어가는 과정에서 다른 프로세스가 진입하는 횟수는 제한이 있어야 한다.

**해결 방법**

-   lock
    -   임계영역을 들어가는 프로세스는 Lock을 획득하고 빠져나올 때 Lock을 해제
-   Semaphore(세마포어)
    -   Counting Semaphore
        -   세마포어의 개수가 자원을 사용할 수 있는 개수로 사용하면 감소, 사용하지 않으면 증가
    -   Binary Semaphore (mutex)
        -   카운팅 세마포어와 다르게 최대 1개만 가능

## 5. 메모리 관리 기법

### 페이징과 세그멘테이션

**페이징(paging)**

물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.

-   외부 단편화를 해결해줌
-   마지막 페이지 프레임은 전부 사용되지 않고 남아버리는 문제가 발생한다.(**내부 단편화**)

**세그멘테이션(segmentation)**

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할

-   서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(**외부 단편화**)

## 6. 가상 메모리

가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법**

-   예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

```
Stack
```

```
Heap
```

```
Data
```

```
Code
```

### **가상 메모리 개발 배경**

실행되는 **코드의 전부를 물리 메모리에 존재시켜야** 했고, **메모리 용량보다 큰 프로그램은 실행시킬 수 없었다.**  또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는게 아니라는 것을 알 수 있다.

-   물리 메모리 크기에 제약받지 않게 된다.
-   더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 `응답시간`은 유지되고, `CPU 이용률`과 `처리율`은 높아진다.
-   [swap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%B0%B0%EA%B2%BD)에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행
-   예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

```
Stack
```

```
Heap
```

```
Data
```

```
Code
```

### **Demand Paging(요구 페이징)**

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략

**페이지 교체 알고리즘**

-   FIFO

    -   `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재

-   최적 페이지 교체(Optimal Page Replacement)
-   LRU 페이지 교체(LRU Page Replacement)
-   LFU 페이지 교체(LFU Page Replacement)
-   MFU 페이지 교체(MFU Page Replacement)

## 7. 쓰레싱

-   Page Fault가 연속적으로 발생하여 프로세스 수행시간보다 페이지 교체 시간이 많은 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a27ea04-186c-475b-b691-d155d6063edd/Untitled.png)

## 8. 교착상태(DeadLock

### 데드락의 발생조건

-   상호배제 : 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다.
-   점유 대기 : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.
-   비선점 : 이미 할당된 자원을 강제로 빼앗을 수 없다.
-   순환 대기 : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다.

### 데드락의 해결법

**데드락 예방(prevention)**

-   발생조건 4가지 중 하나라도 발생하지 않게 하는것

**데드락 회피(avoidance)**

-   시스템의 프로세스들이 요청하는 모든 자원을, 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있다면 **안정 상태**(safe state)에 있다
-   **자원을 할당한 후에도 시스템이 항상 Safe state에 있을 수 있도록 할당을 허용**
-   은행원 알고리즘 사용
    -   **미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부**를 검사

**데드락 탐지(detection) 및 회복(recovery)**

탐지 기법

-   **자원 할당 그래프를 통해 탐지**
-   **데드락이 발생했는지 여부를 탐색**

회복 기법

-   `순환 대기`에서 벗어나 데드락으로부터 회복하기 위한 방법
-   교착 상태에 빠진 모든 프로세스를 중단시키는 방법
-   프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법

## 9. 힙과 스택의 차이

### 스택

-   메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다.
-   스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸합니다.
-   이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.
-   스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출합니다.
-   이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.
-   스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.

### 힙

-   메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역입니다.
-   힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.
-   힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.

## **스택과 힙의 장단점**

### **스택**

-   매우 빠른 액세스
-   변수를 명시 적으로 할당 해제 할 필요가 없습니다.
-   공간은 CPU에 의해 효율적으로 관리되고 메모리는 단편화되지 않습니다.
-   지역 변수 만
-   스택 크기 제한 (OS에 따라 다름)
-   변수의 크기를 조정할 수 없습니다.

### **힙**

-   변수는 전역 적으로 액세스 할 수 있습니다.
-   메모리 크기 제한 없음
-   (상대적으로) 느린 액세스
-   효율적인 공간 사용을 보장하지 못하면 메모리 블록이 할당 된 후 시간이 지남에 따라 메모리가 조각화되어 해제 될 수 있습니다.
-   메모리를 관리해야합니다 (변수를 할당하고 해제하는 책임이 있습니다)
-   변수는 C언어 realloc() or 자바 new
