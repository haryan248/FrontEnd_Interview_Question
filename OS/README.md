## 1. 프로세스와 스레드의 차이

프로세스는 실행중인 프로그램, 메모리에 적재되어 CPU의 할당을 받을 수 있다.

스레드는 프로세스의 실행 단위이며 프로세스 내의 주소공간, 자원을 공유한다.

## 2. 멀티 프로세스와 멀티 스레드의 차이

### 멀티 프로세스

두개 이상 다수의 프로세서(`CPU`)가 협력적으로 하나 이상의 작업(`Task`)을 동시에 처리하는 것

-   하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재

### 멀티 스레드

하나의 프로세스에 여러 스레드로 자원을 공유하며 작업을 나누어 수행하는 것

-   멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점
    → 자원을 효율적으로 관리가 가능
-   오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제(병목 현상, 데드락)
    -   임계영역에 한번에 한 스레드만 실행되도록 lock, monitor, synchronized를 통해 동기화 문제 해결

멀티 프로세스 예시

-   크롬 탭, 카카오톡 채팅방

## 3. CPU 스케쥴러

비선점형 스케쥴링

-   FCFS, SJF, SRTF

선점형 스케쥴링

-   Priority Scheduling(우선순위 스케쥴링), Round Robin

각각의 스케쥴링 방식을 설명할줄 알아야 한다.

## 4. 임계영역(Critical Section)

동일한 자원을 동시에 접근하는 작업을 실행하는 코드 영역

### 임계영역 해결

**기본 조건**

-   Mutual Exclusion(상호 배제)
    -   한 프로세스가 임계영역에서 실행중이라면 다른 프로세스는 실행될 수 없다
-   Progress(진행)
    -   임계영역에 실행되는 프로세스가 없고, 다른 프로세스만 진입이 가능하다.
-   Bounded Waiting(한정된 대기)
    -   임계영역에 프로세스가 들어가는 과정에서 다른 프로세스가 진입하는 횟수는 제한이 있어야 한다.

**해결 방법**

-   lock
    -   임계영역을 들어가는 프로세스는 Lock을 획득하고 빠져나올 때 Lock을 해제
-   Semaphore(세마포어)
    -   Counting Semaphore
        -   세마포어의 개수가 자원을 사용할 수 있는 개수로 사용하면 감소, 사용하지 않으면 증가
    -   Binary Semaphore (mutex)
        -   카운팅 세마포어와 다르게 최대 1개만 가능

## 5. 메모리 관리 기법

### 페이징과 세그멘테이션

**페이징(paging)**

물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.

-   외부 단편화를 해결해줌
-   마지막 페이지 프레임은 전부 사용되지 않고 남아버리는 문제가 발생한다.(**내부 단편화**)

**세그멘테이션(segmentation)**

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할

-   서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(**외부 단편화**)

## 6. 가상 메모리

가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법**

-   예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

```
Stack
```

```
Heap
```

```
Data
```

```
Code
```

### **가상 메모리 개발 배경**

실행되는 **코드의 전부를 물리 메모리에 존재시켜야** 했고, **메모리 용량보다 큰 프로그램은 실행시킬 수 없었다.**  또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는게 아니라는 것을 알 수 있다.

-   물리 메모리 크기에 제약받지 않게 된다.
-   더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 `응답시간`은 유지되고, `CPU 이용률`과 `처리율`은 높아진다.
-   [swap](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EB%B0%B0%EA%B2%BD)에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행
-   예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

```
Stack
```

```
Heap
```

```
Data
```

```
Code
```

### **Demand Paging(요구 페이징)**

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략

**페이지 교체 알고리즘**

-   FIFO

    -   `Belady의 모순`: 페이지를 저장할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재

-   최적 페이지 교체(Optimal Page Replacement)
-   LRU 페이지 교체(LRU Page Replacement)
-   LFU 페이지 교체(LFU Page Replacement)
-   MFU 페이지 교체(MFU Page Replacement)

## 7. 쓰레싱

-   Page Fault가 연속적으로 발생하여 프로세스 수행시간보다 페이지 교체 시간이 많은 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a27ea04-186c-475b-b691-d155d6063edd/Untitled.png)
