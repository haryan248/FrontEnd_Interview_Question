### 구글을 입력하면 벌어지는 일

1. www.google.com을 브라우저 주소창에 친다

2. Browser는 캐싱된 DNS 기록들을 통해 www.google.com에 대응되는 IP 주소가 있는지 확인한다

3. 요청한 URL이 캐시에 없으면, ISP의 DNS 서버가 www.google.com을 호스팅하고 있는 서버의 IP 주소를 찾기 위해 DNS query를 날린다.

4. Browser가 서버와 TCP connection을 한다(TCP 3way- handshaking)

5. Browser가 웹 서버에 HTTP 요청을 한다.

6. 서버가 요청을 처리하고 response를 생성한다

7. 서버가 HTTP response를 보낸다

8. Browser가 HTML content를 보여준다

[https://devjin-blog.com/what-happen-browser-search/](https://devjin-blog.com/what-happen-browser-search/)

### 브라우저의 동작 원리(랜더링 원리)

![image](https://user-images.githubusercontent.com/51049245/142718390-35c7621e-34c9-4931-94f4-1a4ce931ac4d.png)

-   사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 등 페이지 뷰 이외의 다른 부분
-   브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이 동작 제어
-   렌더링 엔진: HTML, CSS를 파싱해 화면에 요청한 컨텐츠를 표시
-   통신: HTTP요청과 같은 네트워크 호출에 사용됨
-   JS 엔진: 자바스크립트 코드를 해석하고 실행
-   UI 백엔드: 기본적인 위젯(콤보 박스 등)을 그림
-   자료 저장소: 자료를 저장하는 계층으로 쿠키 등을 저장하는 웹 데이터베이스

1. HTML 마크업을 처리하고 DOM 트리를 빌드한다. (**"무엇을"** 그릴지 결정한다.)
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. (**"어떻게"** 그릴지 결정한다.)
3. DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. (**"화면에 그려질 것만"** 결정)
4. 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. (**"Box-Model"** 을 생성한다.)
5. 개별 노드를 화면에 페인트한다.(or 래스터화)

### CORS란?(Cross-Origin Resource Sharing) 와 SOP

다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 **cross-origin HTTP 요청** 에 의해 요청된다. 하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다. 이것을 `Same-Origin-Policy(동일 근원 정책)`이라고 한다. 요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜도 같아야 하고, 포트도 같아야 함을 의미한다.

포트까지 모두 일치해야 같은 origin이라고 판단하고 같은 출처의 경우에만 허용

**장점**

동일 출처 정책을 지키면 외부 리소스를 가져오지 못해 불편하지만, 동일 출처 정책은 [XSS](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85)나 [XSRF](https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9D%B4%ED%8A%B8_%EA%B0%84_%EC%9A%94%EC%B2%AD_%EC%9C%84%EC%A1%B0) 등의 보안 취약점을 노린 공격을 방어

**CORS 동작 방식**

라우저는 요청 헤더에 **`Origin`**이라는 필드에 요청을 보내는 출처를 함께 담아보낸다.

**`Access-Control-Allow-Origin`**이라는 값에 “이 리소스를 접근하는 것이 허용된 출처”를 내려주고, 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 **`Origin`**과 서버가 보내준 응답의 **`Access-Control-Allow-Origin`**을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정

**Preflight Request(예비 요청)**

서버에 예비 요청을 보내서 안전한지 판단한 후 본 요청을 보내는 방법

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bfb2d0f4-7560-49eb-976b-2a2238c6ffa1/Untitled.png)

**Simple Request**

-   예비요청을 보내지 않고 바로 서버에게 본요청을 보낸후 CORS 정책 위반여부를 검사
-   이는 특정 조건을 만족하는 경우에만 예비 요청을 생략할 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7f896f57-00c8-4ec9-ad45-57ba4dd01ed0/Untitled.png)

-   요청 메서드(method)는 GET, HEAD, POST 중 하나여야 합니다.
-   Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안 됩니다.
-   Content-Type 헤더는 application/x-www-form-urlencoded, multipart/form-data, text/plain 중 하나를 사용해야 합니다.

CORS 에러 해결 방법

-   `Access-Control-Allow-Origin` 헤더에 작성된 출처만 브라우저가 리소스를 접근할 수 있도록 허용합니다
-   프록시 서버 : 프론트엔드와 백엔드 사이에 프록시 서버를 두는 방법으로 CORS를 해결

### 바벨과 폴리필

폴리필은 **런-타임**에 필요한 기능을 주입

브라우저에서 실행되는 시점에 필요한 기능을 주입

바벨은 **구 브라우저**에서도 최신자바스크립트 코드를 작동하도록 변환해주는 컴파일러(혹은 트랜스파일러)

**_Promise, Map, Set 같은 전역객체_**들이나 **_String.padStart등 전역 객체에 추가된 메서드_**등 컴파일-타임의 코드변환으로는 해결하기 어렵기 때문에 **_폴리필(polyfill)_** 이 필요한 것

### 웹팩(webpack)이란?

웹팩이란 최신 프런트엔드 프레임워크에서 가장 많이 사용되는 **[모듈 번들러(Module Bundler)](https://joshua1988.github.io/webpack-guide/webpack/what-is-webpack.html)**입니다. 모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도

**웹팩으로 해결하려는 문제?**

-   자바스크립트 변수 유효 범위
-   브라우저별 HTTP 요청 숫자의 제약
-   사용하지 않는 코드의 관리
-   Dynamic Loading & Lazy Loading 미지원

## import vs require 차이

모듈 시스템은 CommonJS 방식에 비해 코드의 직관성이 좋고, 비동기 방식으로 작동하면서 불러오는 모듈의 실제로 사용되는 부분들만 로드하기 때문에 성능적으로도 효율적

# HTTP 메소드

### GET 방식

우선 GET 방식은 요청하는 데이터가 `HTTP Request Message`의 Header 부분에 url 이 담겨서 전송된다. 때문에 url 상에 `?` 뒤에 데이터가 붙어 request 를 보내게 되는 것이다. 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 `GET`방식은 적절하지 않다.

## POST 방식

POST 방식의 request 는 `HTTP Request Message`의 Body 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.

### PUT vs PATCH

PATCH도 수정을 담당하는 메서드라는데, PUT도 수정에 사용되는 거라고 한다. 그렇다면 이 둘은 어떻게 다른 것인가?

*PATCH는 수정만 담당하며 리소스의 일부분만 수정*할 때 사용하고, *PUT은 리소스의 모든 속성을 수정*하기 위해 사용한다.

## 쿠키 vs 세션

**쿠키와 세션을 사용하는 이유**

HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용된다.

1. **Connectionless 프로토콜 (비연결지향)**

    클라이언트가 서버에 요청(Request)을 했을 때,그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식이다.

    - HTTP 1.1 버전에서 연결을 유지하고, 재활용 하는 기능이 Default 로 추가되었다.(keep-alive 값으로 변경 가능)

2. **Stateless 프로토콜 (상태정보 유지 안함)**클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도,두번째 통신에서 이전 데이터를 유지하지 않는다.

    클라이언트의 상태 정보를 가지지 않는 서버 처리 방식이다.

**세션을 쓰면되는데 굳이 쿠키를 사용하는 이유?**

**A.** 세션이 쿠키에 비해 보안도 높은 편이나 쿠키를 사용하는 이유는세션은 서버에 저장되고, 서버자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하다.이러한 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여,서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다.

## **쿠키(Cookie)**

HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우,그 사이트가 사용하고 있는 서버에서 **사용자의 컴퓨터에 저장하는 작은 기록 정보 파일**이다.

HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가**필요시 정보를 참조하거나 재사용할 수 있다.**

-   **쿠키 특징**
    1. 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
    2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다.
    3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다
    4. 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.
-   **쿠키의 동작 순서**
    1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
    2. 웹 서버는 쿠키를 생성한다.
    3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때,같이 클라이언트에게 돌려준다.
    4. 넘겨 받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장)다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
    5. 동일 사이트 재방문시 클라이언트의 PC에 해당 쿠키가 있는 경우,요청 페이지와 함께 쿠키를 전송한다.
-   **사용 예시**
    1. 방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
    2. 팝업창을 통해 "오늘 이 창을 다시 보지 않기" 체크

## **세션(Session)**

일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술이다.

여기서 일정 시간은 방문자가 웹 브라우저를 통해웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점을 말한다.즉, **방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션**이라고 한다.

-   **세션 특징**
    1. 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.
    2. 웹 서버의 저장되는 쿠키(=세션 쿠키)
    3. 브라우저를 닫거나, 서버에서 세션을 삭제했을때만 삭제가 되므로,쿠키보다 비교적 보안이 좋다.
    4. 저장 데이터에 제한이 없다.(서버 용량이 허용하는 한...)
    5. 각 클라이언트 고유 Session ID를 부여한다.Session ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스 제공
-   **세션의 동작 순서**
    1. 클라이언트가 페이지를 요청한다. (사용자가 웹사이트 접근)
    2. 서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여,클라이언트가 해당 session-id를 보냈는지 확인한다.
    3. session-id가 존재하지 않는다면,서버는 session-id를 생성해 클라이언트에게 돌려준다.
    4. 서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.쿠키 이름 : JSESSIONID
    5. 클라이언트는 재접속 시,이 쿠키(JSESSIONID)를 이용하여 session-id 값을 서버에 전달
-   **사용 예시**
    -   화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

## 쿠키 스토리지 vs 세션 스토리지 vs 로컬 스토리지

### **1. 쿠키 (Cookie)**

-   **클라이언트가 서버에 방문한 정보를 클라이언트 단에 저장하는 작은 파일**을 의미한다.
-   클라이언트의 브라우저 메모리 혹은 하드디스크에 저장이 된다. (↔ 세션)
-   **매번 서버에 전송**되므로 크기가 클 경우 서버에 부담이 갈 수 있다.
-   SameSite 옵션이 Strict가 아닌 경우, **다른 도메인에서 요청할 때도 자동 전송**되는 위험성이 있다. (CSRF 취약)
-   대략 **4KB**까지의 데이터를 저장할 수 있으며 **유효 기간이 존재**한다.
-   대부분의 브라우저가 지원한다.

### **2. 웹 스토리지 (Web Storage)**

-   **클라이언트에 데이터를 저장할 수 있도록 HTML5부터 새롭게 지원하는 저장소**이다.
-   키(Key)와 값(Value)의 쌍 형태로 데이터를 저장한다.
-   쿠키와 달리, **서버에 전송되지 않으므로** 서버에 부담이 가지 않는다. (명시적으로만 전송 가능)
-   쿠키와 달리, **필요한 경우에만 꺼내 쓰는 것**이므로 자동 전송의 위험성이 없다. 다른 도메인에서 요청하는 경우에는, 꺼내 쓰고 싶어도 도메인 단위로 접근이 제한되는 특성 덕분에 값을 꺼내 쓸 수 없다. (CSRF 안전)
-   쿠키와 달리, 대략 **5MB**까지의 데이터를 저장할 수 있으며 **유효 기간이 존재하지 않는다.**
-   HTML5를 지원하지 않는 브라우저에서는 사용할 수 없다.
-   종류로는 **로컬 스토리지(Local Storage)**와 **세션 스토리지(Session Storage)**가 있다. 이들은 window 객체의 프로퍼티로서 존재하며, 같은 Storage 객체를 상속하기 때문에 동일한 메소드들을 가진다. 이 둘의 가장 큰 차이점은 데이터의 **영구성**이다.

### **3. 로컬 스토리지 (Local Storage)**

-   window.localStorage 객체
-   **브라우저를 종료해도 유지되는 데이터로, 명시적으로 지우지 않는 한 영구적으로 저장**된다.
-   **도메인별**로 생성되며, 다른 도메인의 로컬 스토리지에는 접근이 불가능하다.
-   서로 다른 브라우저 탭이라도 동일한 도메인이라면 동일한 로컬 스토리지를 사용한다.
-   지속적으로 필요한 정보를 저장하기에 좋다. (ex. 자동 로그인 등)

### **4. 세션 스토리지 (Session Storage)**

-   window.sessionStorage 객체
-   세션 쿠키와 달리, **탭/윈도우 단위**로 세션 스토리지가 생성된다.
-   즉 window 객체와 동일한 유효 범위 및 생존 기간을 가지며, 탭/윈도우를 닫을 시 데이터가 삭제된다.
-   또한 동일한 탭/윈도우라도 **다른 도메인이라면 또 다른 세션 스토리지가 생성**된다.
-   서로 다른 세션 스토리지는 서로 영향을 주지 않으며 **독립적**으로 동작한다.
-   윈도우 복제로 생성된 경우, 혹은 스크립트로 새 창을 연 경우 세션 스토리지가 복제되어 생성된다.
-   잠시 동안 필요한 정보를 저장하기에 좋다. (ex. 입력 폼 저장, 일회성 로그인 등)

## 양방향 데이터 바인딩 vs 단방향 데이터 바인딩

> 데이터 바인딩이란?

화면에 보이는 데이터와 브라우저 메모리에 있는 데이터(여러 개의 자바스크립트 객체)를 일치시키는 것을 말합니다.

예를 들면 mvc 모델에서 model과 view를 서로 묶어 **model과 view의 데이터를 서로 자동 동기화시키는 것으로** 이해할 수 있습니다.

**단방향 데이터 바인딩의 장단점**

**장점:** 데이터의 변화에 따른 성능 저하 없이 DOM객체 갱신 가능합니다.

데이터 흐름이 단방향(부모 -> 하위 컴포넌트)이어서 코드를 이해하기 쉽고 데이터의 추적과 디버깅이 쉽습니다.

**단점:** 변화를 감지하고 화면을 업데이트하는 코드를 매번 작성해야 됩니다.

**양방향 데이터 바인딩의 장단점**

**장점:** 코드의 사용면에서 코드량을 크게 줄여 줍니다.

**단점:** 변화에 따라 DOM 객체 전체를 랜더링 해주거나 데이터를 바꿔주므로 성능이 감소되는 경우가 있습니다.

## babel plugins에서는 번들로 babel preset이 함께 온다

babel foundation에서는 **plugin들을 포함한 번들(plugin들을 모아놓은 파일이라고 생각하면 된다)파일을 포함 `preset`을 만들었다.**

npm 설치와 babel 설정을 한번만 하면 plugin들이 자동적으로 설치

다양한 babel preset들이 있는데 babel foundadtion에서 제공하는 **공식 preset**과 Airbnb같은 곳에서 제공하는 **비공식 preset**이 있다. 심지어 우리가 만들 수도 있다.

공식 preset은:

-   @babel/preset-env
-   @babel/preset-flow
-   @babel/preset-react
-   @babel/preset-typescript

각각의 preset은우리가 설치 설정해야할 npm dependency를 가지고 있다.드디어 우리는 `babel-preset-env`를 실행할 준비가 되었다

[https://jeonghwan-kim.github.io/series/2019/12/22/frontend-dev-env-babel.html](https://jeonghwan-kim.github.io/series/2019/12/22/frontend-dev-env-babel.html)
